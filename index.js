#!/usr/bin/env node
/**
 * sshm-cli - simple Node CLI to store ssh credentials in OS keyring and auto-login
 *
 * Usage:
 *   sshm add
 *   sshm list
 *   sshm remove <alias>
 *   sshm connect <alias>
 *   sshm <alias>
 *
 * Notes:
 *  - Requires: ssh available in PATH
 *  - Uses keytar to store passwords securely in OS keyring
 *  - Uses node-pty to spawn a pty and detect password prompts, host key prompts
 */

import { Command } from 'commander';
import inquirer from 'inquirer';
import fs from 'fs';
import os from 'os';
import path from 'path';
import { spawn } from 'child_process';
import { getServers, saveServers, savePassword, getPassword, deletePassword, saveKeyContent, regenerateKeyFile, regenerateAllKeyFiles } from './lib/store.js';

// Function to handle SSH connection
async function handleSSH(name) {
  const servers = getServers();
  if (servers.length === 0) return console.log('‚ö†Ô∏è Ch∆∞a c√≥ server n√†o.');

  const server = servers.find(s => s.name === name);
  if (!server) return console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y server: ${name}`);

  // ƒê·∫£m b·∫£o server lu√¥n c√≥ port, m·∫∑c ƒë·ªãnh l√† 22
  if (!server.port) server.port = '22';

  // If server has keyPath, use SSH key; otherwise fall back to password
  if (server.keyPath) {
    // expand ~ to home
    let keyPath = server.keyPath.replace(/^~(?=$|\/)/, os.homedir());
    
    // If key file doesn't exist, try to regenerate it from stored content
    if (!fs.existsSync(keyPath)) {
      console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file key: ${keyPath}`);
      console.log(`üîÑ ƒêang th·ª≠ t√°i t·∫°o key file...`);
      try {
        keyPath = await regenerateKeyFile(name);
        keyPath = keyPath.replace(/^~(?=$|\/)/, os.homedir());
        if (!fs.existsSync(keyPath)) {
          return console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ t√°i t·∫°o key file cho server: ${name}`);
        }
      } catch (error) {
        return console.log(`‚ö†Ô∏è ${error.message}`);
      }
    }
    
    // Validate key file before using
    try {
      const keyContent = fs.readFileSync(keyPath, 'utf8');
      if (!keyContent.includes('BEGIN') || !keyContent.includes('PRIVATE KEY')) {
        console.log(`‚ö†Ô∏è Key file kh√¥ng h·ª£p l·ªá: ${keyPath}`);
        console.log(`üîÑ ƒêang th·ª≠ t√°i t·∫°o key file...`);
        try {
          keyPath = await regenerateKeyFile(name);
          keyPath = keyPath.replace(/^~(?=$|\/)/, os.homedir());
        } catch (error) {
          return console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ t√°i t·∫°o key file: ${error.message}`);
        }
      }
    } catch (e) {
      console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc key file: ${keyPath}`);
      return;
    }
    
    console.log(`üîê ƒêang k·∫øt n·ªëi b·∫±ng SSH key t·ªõi ${server.user}@${server.host}:${server.port}...`);
    // console.log(`üîë S·ª≠ d·ª•ng SSH key: ${keyPath}`);
    const ssh = spawn('ssh', [
      '-o', 'StrictHostKeyChecking=no',
      '-o', 'UserKnownHostsFile=/dev/null',
      '-o', 'LogLevel=ERROR',
      '-p', server.port,
      '-i', keyPath,
      `${server.user}@${server.host}`
    ], { stdio: 'inherit' });

    ssh.on('exit', code => {
      if (code === 0) {
        console.log(`üîå ƒê√£ tho√°t kh·ªèi SSH th√†nh c√¥ng`);
      } else {
        console.log(`üîå SSH connection failed v·ªõi m√£: ${code}`);
        if (code === 255) {
          console.log(`üí° G·ª£i √Ω: Ki·ªÉm tra l·∫°i key file ho·∫∑c server c√≥ ch·∫•p nh·∫≠n key n√†y kh√¥ng`);
        }
      }
      process.exit(code);
    });
    return;
  }

  const password = await getPassword(name);
  if (!password) return console.log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y password ƒë√£ l∆∞u.');
  
  console.log(`üîê ƒêang k·∫øt n·ªëi t·ªõi ${server.user}@${server.host}:${server.port}...`);
  const sshPassProc = spawn('sshpass', [
    '-p', password,
    'ssh',
    '-o', 'StrictHostKeyChecking=no',
    '-o', 'UserKnownHostsFile=/dev/null',
    '-o', 'LogLevel=ERROR',
    '-p', server.port,
    `${server.user}@${server.host}`
  ], {
    stdio: 'inherit'
  });

  sshPassProc.on('exit', code => {
    console.log(`üîå ƒê√£ tho√°t kh·ªèi SSH v·ªõi m√£: ${code}`);
    process.exit(code);
  });
}

const program = new Command();

program
  .name('sshm')
  .description('CLI qu·∫£n l√Ω v√† SSH nhanh v√†o server')
  .version('1.0.0')
  .argument('[name]', 'T√™n server ƒë·ªÉ k·∫øt n·ªëi tr·ª±c ti·∫øp')
  .action(async (name) => {
    try {
      let serverName = name;
      const servers = getServers();

      if (!serverName) {
        const answer = await inquirer.prompt([
          {
            type: 'list',
            name: 'name',
            message: 'Ch·ªçn server ƒë·ªÉ SSH:',
            choices: servers.map(s => `${s.name} (${s.user}@${s.host}:${s.port || '22'})`)
          }
        ]);
        serverName = answer.name.split(' ')[0]; // L·∫•y ph·∫ßn t√™n tr∆∞·ªõc d·∫•u space
      }

      await handleSSH(serverName);
    } catch (e) {
      program.help()
    }
  });

program
  .command('add')
  .description('Th√™m server m·ªõi')
  .action(async () => {
    const answers = await inquirer.prompt([
      { type: 'input', name: 'name', message: 'T√™n server:' },
      { type: 'input', name: 'host', message: 'ƒê·ªãa ch·ªâ host:' },
      { type: 'input', name: 'user', message: 'T√™n user SSH:' },
      { type: 'input', name: 'port', message: 'Port SSH:', default: '22' },
      {
        type: 'list',
        name: 'auth',
        message: 'Ph∆∞∆°ng th·ª©c x√°c th·ª±c:',
        choices: [
          { name: 'Password', value: 'password' },
          { name: 'SSH key', value: 'key' }
        ],
        default: 'password'
      },
      { type: 'password', name: 'password', message: 'M·∫≠t kh·∫©u SSH:', when: a => a.auth === 'password' },
      {
        type: 'list',
        name: 'keyMethod',
        message: 'C√°ch nh·∫≠p key:',
        when: a => a.auth === 'key',
        choices: [
          { name: 'D√πng file key c√≥ s·∫µn', value: 'file' },
          { name: 'D√°n n·ªôi dung key', value: 'paste' }
        ]
      },
      { type: 'input', name: 'keyPath', message: 'ƒê∆∞·ªùng d·∫´n private key:', default: '~/.ssh/id_rsa', when: a => a.auth === 'key' && a.keyMethod === 'file' },
      { type: 'editor', name: 'keyContent', message: 'D√°n n·ªôi dung private key v√†o ƒë√¢y (Ctrl+S ƒë·ªÉ l∆∞u, Ctrl+Q ƒë·ªÉ tho√°t):', when: a => a.auth === 'key' && a.keyMethod === 'paste' }
    ]);

    const servers = getServers();
    const server = {
      name: answers.name,
      host: answers.host,
      user: answers.user,
      port: answers.port || '22'
    };

    if (answers.auth === 'key') {
      if (answers.keyMethod === 'paste' && answers.keyContent) {
        // write pasted key content to a secure file under ~/.sshm/keys
        const keysDir = path.join(os.homedir(), '.sshm', 'keys');
        if (!fs.existsSync(keysDir)) {
          fs.mkdirSync(keysDir, { recursive: true, mode: 0o700 });
        }
        
        const keyFile = path.join(keysDir, `${answers.name}_key`);
        
        // Validate key content
        const keyContent = answers.keyContent.trim();
        if (!keyContent) {
          console.log('‚ö†Ô∏è Kh√¥ng c√≥ n·ªôi dung key. H·ªßy.');
          return;
        }
        
        if (!keyContent.includes('PRIVATE KEY')) {
          console.log('‚ö†Ô∏è N·ªôi dung kh√¥ng ph·∫£i private key h·ª£p l·ªá. H·ªßy.');
          return;
        }
        
        // Write key with proper permissions
        fs.writeFileSync(keyFile, keyContent + '\n', { mode: 0o600 });
        try {
          fs.chmodSync(keyFile, 0o600);
          console.log(`üîë ƒê√£ l∆∞u key v√†o: ~/.sshm/keys/${answers.name}_key`);
        } catch (e) {
          console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ set quy·ªÅn 600 cho file key');
        }
        
        // Save key content to credentials for regeneration
        await saveKeyContent(answers.name, keyContent);
        
        server.keyPath = `~/.sshm/keys/${answers.name}_key`;
      } else if (answers.keyMethod === 'file') {
        // L∆∞u ƒë∆∞·ªùng d·∫´n v·ªõi ~/
        server.keyPath = answers.keyPath;
        // Ki·ªÉm tra file t·ªìn t·∫°i b·∫±ng ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß
        const fullKeyPath = answers.keyPath.replace(/^~(?=$|\/)/, os.homedir());
        if (!fs.existsSync(fullKeyPath)) {
          console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file key: ${answers.keyPath}`);
          return;
        }
      } else {
        console.log('‚ö†Ô∏è Thi·∫øu th√¥ng tin key SSH. H·ªßy.');
        return;
      }
    }

    servers.push(server);
    saveServers(servers);

    if (answers.auth === 'password') {
      await savePassword(answers.name, answers.password);
    }

    console.log(`‚úÖ ƒê√£ l∆∞u server "${answers.name}"`);
  });

program
  .command('ls')
  .description('Li·ªát k√™ danh s√°ch server')
  .action(() => {
    const servers = getServers();
    if (servers.length === 0) return console.log('‚ö†Ô∏è Ch∆∞a c√≥ server n√†o.');
    
    // Hi·ªÉn th·ªã ch·ªâ th√¥ng tin auth type
    const authInfo = servers.map(server => ({
      name: server.name,
      host: server.host,
      auth: server.keyPath ? 'SSH Key' : 'Password'
    }));
    
    console.table(authInfo);
  });

program
  .command('rm [name]')
  .description('X√≥a server theo t√™n (n·∫øu kh√¥ng truy·ªÅn s·∫Ω hi·ªÉn th·ªã menu)')
  .action(async (name) => {
    const servers = getServers();
    if (servers.length === 0) return console.log('‚ö†Ô∏è Ch∆∞a c√≥ server n√†o.');

    let targetName = name;
    if (!targetName) {
      const answer = await inquirer.prompt([{ type: 'list', name: 'name', message: 'Ch·ªçn server c·∫ßn x√≥a:', choices: servers.map(s => s.name) }]);
      targetName = answer.name;
    }

    const idx = servers.findIndex(s => s.name === targetName);
    if (idx === -1) return console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y server: ${targetName}`);

    const { confirm } = await inquirer.prompt([{ type: 'confirm', name: 'confirm', message: `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a "${targetName}"?`, default: false }]);
    if (!confirm) return console.log('H·ªßy x√≥a.');

    const [removed] = servers.splice(idx, 1);
    saveServers(servers);

    // delete password if any
    try { await deletePassword(removed.name); } catch (e) { /* ignore */ }

    // delete key file if it is inside ~/.sshm/keys
    try {
      const keysDir = path.join(os.homedir(), '.sshm', 'keys');
      const fullKeyPath = removed.keyPath ? removed.keyPath.replace(/^~(?=$|\/)/, os.homedir()) : null;
      if (fullKeyPath && fullKeyPath.startsWith(keysDir) && fs.existsSync(fullKeyPath)) {
        fs.unlinkSync(fullKeyPath);
      }
    } catch (e) { /* ignore */ }

    console.log(`‚úÖ ƒê√£ x√≥a server "${targetName}"`);
  });

program
  .command('connect [name]')
  .description('Ch·ªçn server ƒë·ªÉ SSH')
  .action(async (nameArg) => {
    const servers = getServers();
    if (servers.length === 0) return console.log('‚ö†Ô∏è Ch∆∞a c√≥ server n√†o.');

    let targetName = nameArg;
    if (!targetName) {
      const answer = await inquirer.prompt([
        {
          type: 'list',
          name: 'name',
          message: 'Ch·ªçn server ƒë·ªÉ SSH:',
          choices: servers.map(s => `${s.name} (${s.user}@${s.host}:${s.port || '22'})`)
        }
      ]);
      targetName = answer.name.split(' ')[0]; // L·∫•y ph·∫ßn t√™n tr∆∞·ªõc d·∫•u space
    }

    await handleSSH(targetName);
  });

program
  .command('regen [name]')
  .description('T√°i t·∫°o key file t·ª´ content ƒë√£ l∆∞u')
  .action(async (nameArg) => {
    const servers = getServers();
    const keyServers = servers.filter(s => s.keyPath);
    
    if (keyServers.length === 0) return console.log('‚ö†Ô∏è Kh√¥ng c√≥ server n√†o s·ª≠ d·ª•ng SSH key.');
    
    let targetName = nameArg;
    if (!targetName) {
      const answer = await inquirer.prompt([
        {
          type: 'list',
          name: 'name',
          message: 'Ch·ªçn server ƒë·ªÉ t√°i t·∫°o key:',
          choices: keyServers.map(s => `${s.name} (${s.user}@${s.host})`)
        }
      ]);
      targetName = answer.name.split(' ')[0]; // L·∫•y ph·∫ßn t√™n tr∆∞·ªõc d·∫•u space
    }
    
    try {
      await regenerateKeyFile(targetName);
      console.log(`‚úÖ ƒê√£ t√°i t·∫°o key file cho server "${targetName}"`);
    } catch (error) {
      console.log(`‚ö†Ô∏è ${error.message}`);
    }
  });

program
  .command('regen-all')
  .description('T√°i t·∫°o t·∫•t c·∫£ key files t·ª´ content ƒë√£ l∆∞u (d√πng khi th∆∞ m·ª•c keys b·ªã x√≥a)')
  .action(async () => {
    console.log('üîÑ ƒêang t√°i t·∫°o t·∫•t c·∫£ key files...');
    const results = await regenerateAllKeyFiles();
    
    if (results.length === 0) {
      console.log('‚ÑπÔ∏è Kh√¥ng c√≥ key n√†o ƒë·ªÉ t√°i t·∫°o.');
      return;
    }
    
    const successCount = results.filter(r => r.status === 'success').length;
    const failedCount = results.filter(r => r.status === 'failed').length;
    
    console.log(`\nüìä K·∫øt qu·∫£ t√°i t·∫°o:`);
    console.log(`‚úÖ Th√†nh c√¥ng: ${successCount}`);
    console.log(`‚ùå Th·∫•t b·∫°i: ${failedCount}`);
    
    if (failedCount > 0) {
      console.log('\n‚ö†Ô∏è C√°c key th·∫•t b·∫°i:');
      results.filter(r => r.status === 'failed').forEach(r => {
        console.log(`  - ${r.name}: ${r.reason}`);
      });
    }
  });

program.parseAsync();